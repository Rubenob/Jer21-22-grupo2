<html><head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>G.H.O.S.T. PROYECT</title>

<script type="text/javascript" src="js/phaser.js"></script>

<script>
var config = {
    type: Phaser.AUTO,
    width: 880,
    height: 320,
    backgroundColor: '#2d2d2d',
    pixelArt: true,
    parent: "game-container",
    
    physics: {
        default: 'matter',
        matter: {
            gravity: { y: 0 },
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

//var controls;

var game = new Phaser.Game(config);

//Parametros isometricos
var data;
var tilewidth;
var tileheight;
var tileWidthHalf;
var tileHeightHalf;
var numLayers;
var mapwidth;
var mapheight;
var centerX;
var centerY;

var cursors;
var tiles;
var player;
const speed = 0.09;

function xIso(xO,yO){
	var xI;
	var txO = (xO - yO) * tileWidthHalf;
	xI = centerX + txO;
	return xI;
}


function yIso(xO,yO){
	var yI;
	var tyO = (xO + yO) * tileHeightHalf;
	yI = centerY + tyO;
	return yI;
}

function dIso(xO,yO,l){
	var dI;
	var tyO = (xO + yO) * tileHeightHalf;
	dI = (centerY + tyO)+tileHeightHalf*l;
	return dI+l;
}

function xOrt(xI,yI){
	var xO,yO;

	yO= (((-xI + centerX)/tileWidthHalf) + ((yI-centerY)/tileHeightHalf))/2;
	xO= (xI - centerX + (yO*tileWidthHalf))/tileWidthHalf;
	return xO;
}
function yOrt(xI,yI){
	var yO;

	yO= (((-xI + centerX)/tileWidthHalf) + ((yI-centerY)/tileHeightHalf))/2;
	return yO;
}



function preload ()
{
	//map
	this.load.spritesheet('tiles', 'assets/tilemaps/tiles_Iso.png', { frameWidth: 32, frameHeight: 16 });
	this.load.json('map', 'assets/tilemaps/map.json');

	//llave
	this.load.image('llave','assets/image/llave.png');

	//player_h
	this.load.spritesheet('player_h', 'assets/spritesheets/player_h/player_h_idel.png', { frameWidth: 32, frameHeight: 82 });
	this.load.json('shapes_h', 'assets/spritesheets/player_h/player_h.json');
}

function create ()
{
	//  Input Events
    cursors = this.input.keyboard.createCursorKeys();

    this.anims.create({
        key: 'idel',
        frames: this.anims.generateFrameNumbers('player_h', { start: 0, end: 9 }),
        frameRate: 10,
        repeat: -1
    });



	//  Parse the data out of the map
        
        var layer;
        var tile;
        var cat1 = this.matter.world.nextCategory();

        //Información del mapa 
		data = this.cache.json.get('map');
        tilewidth = data.tilewidth;
		tileheight = data.tileheight;
		tileWidthHalf = tilewidth / 2;
		tileHeightHalf = tileheight / 2;
		numTilesLayers = data.layers.length-2;
		numLayers = data.layers.length;

		var createObjectsLayer = data.layers[numLayers-1].objects;
		var actionsLayer = data.layers[numLayers-2].objects;

		//Los tamaños de todas las capas del mapa tienen que ser iguales
		mapwidth = data.layers[0].width;
		mapheight = data.layers[0].height;

		centerX = mapwidth * tileWidthHalf;
		centerY = mapheight * tileHeightHalf;
		

        for(var l = 0; l<numTilesLayers; l++){

        	layer = data.layers[l].data;
        	
	        let i = 0;
	        for (let y = 0; y < mapheight; y++)
	        {
	            for (let x = 0; x < mapwidth; x++)
	            {
	                const id = layer[i] - 1;
	                if(id != -1){

	                	tile = this.matter.add.image(xIso(x,y), yIso(x,y), 'tiles', id, {
	                		isStatic: true,
	                		vertices:[{"x":0,"y":0}, 
	                                  {"x":15,"y":7}, 
	                                  {"x":30,"y":0}, 
	                                  {"x":15,"y":-7}],
	                	})
	                	if(l < 2 ){
	                		if(id == 6 || id == 3){
	                		tile.setCollisionCategory(cat1);
	                		}
	                	}

	                	tile.setStatic(true);
	                	tile.name = '[ "xy",' + x + "," + y+ "]";

	                	//incluye acciones
	                	for (o = 0; o < actionsLayer.length; o++){
	                		if(x == Math.round(actionsLayer[o].x / 16)){
	                			if(y == Math.round(actionsLayer[o].y / 16)){
	                				tile.setStatic(true);
	                				tile.name =  actionsLayer[o].name;
	                				tile.setCollisionCategory(cat1);
	                			}
	                		}
	                	}

	                	//(x == 3 && y ==92){
	                		
	                	//}

	                tile.depth = dIso(x,y,l);
	                }

	                i++;

	            }
	        }
        }
        
        //creacion de los objetos
        for (o = 0; o < createObjectsLayer.length; o++){
        	var object;
	        var object_x = Math.round(createObjectsLayer[o].x / 16);
	        var object_y = Math.round(createObjectsLayer[o].y / 16);
	        var object_name =  JSON.parse(createObjectsLayer[o].name);
        	   
        	object = this.matter.add.image(xIso(object_x,object_y), yIso(object_x,object_y), object_name[0], 0, {
	                		isStatic: true,
	                		vertices:[{"x":0,"y":0}, 
	                                  {"x":15,"y":7}, 
	                                  {"x":30,"y":0}, 
	                                  {"x":15,"y":-7}],
	                	});
        	object.depth = dIso(xOrt(object.x,object.y),yOrt(object.x,object.y),1);
        	object.setCollisionCategory(cat1);
        	object.name = createObjectsLayer[o].name;

	    }


        //console.log(objectLayer);
        
		//LLave
        /*var llave;
        var llave_x = 12;
        var llave_y = 64;        
        llave = this.matter.add.image(xIso(llave_x,llave_y), yIso(llave_x,llave_y), 'llave', 0, {
	                		isStatic: true,
	                		vertices:[{"x":0,"y":0}, 
	                                  {"x":15,"y":7}, 
	                                  {"x":30,"y":0}, 
	                                  {"x":15,"y":-7}],
	                	});
        llave.depth = dIso(xOrt(llave.x,llave.y),yOrt(llave.x,llave.y),1);
        llave.setCollisionCategory(cat1);
        llave.name = '['+'"LALLAVE",0,0'+']';*/


        //Jugador humano
        var shapes_h = this.cache.json.get('shapes_h');
        //Coordenadas en ortogonal iniciales
        var player_h_x = 14;
        var player_h_y = 64;
        var player_h_l = 1; 

        player_h = this.matter.add.sprite(xIso(player_h_x,player_h_y), yIso(player_h_x,player_h_y), 'player_h', 0,{shape: shapes_h.player_h});
		/*player_h = this.matter.add.sprite(xIso(player_h_x,player_h_y), yIso(player_h_x,player_h_y), 'player_h', 0,{shape: shapes_h.player_h});*/

        player_h.setStatic(false);
        player_h.setFriction(0);
        player_h.setCollisionCategory(cat1);
        player_h.setCollidesWith(cat1);
        player_h.name = "ELPEPE";

        

        //Camara
        this.cameras.main.setSize(440, 320);
        const cam2 = this.cameras.add(440, 0, 440, 320);
		this.cameras.main.startFollow(player_h);
		cam2.startFollow(player_h, false, 0.5, 0.5);

		var inventario = new Set([]);
		

        //Colisiones
        this.matter.world.on('collisionstart', function (event) {
        	//console.log("name: " + event.pairs[0].bodyA.gameObject.name);
        	//console.log("name: " + event.pairs[0].bodyB.gameObject.name);
        	event.pairs[0].bodyA.gameObject.setTint(0x000000);
        	var accion =  JSON.parse(event.pairs[0].bodyA.gameObject.name);
        	//console.log(accion);
        	if(accion[0] == "tp"){
        		var condicion = new Set (accion[3]);
        		var interseccion = new Set ([...inventario].filter(x => condicion.has(x)));
        		if(interseccion.size == condicion.size){
        			player_h.x = xIso(accion[1],accion[2]);
        			player_h.y = yIso(accion[1],accion[2]);
        		}
        		//event.pairs[0].bodyA.gameObject.name = '["tp",30,46]';
        	}
        	if(accion[0] == "llave"){
        		inventario.add(accion[1]);
        		event.pairs[0].bodyA.gameObject.destroy();
        		console.log(inventario);
        		//event.pairs[0].bodyA.gameObject.name = '["tp",30,46]';
        	}
			
        	

    	});
}




function update (time, delta)
{
	player_h.depth = dIso(xOrt(player_h.x,player_h.y),yOrt(player_h.x,player_h.y),1);;
    if (cursors.left.isDown)
    {	
        player_h.x = xIso(xOrt(player_h.x,player_h.y)- speed, yOrt(player_h.x,player_h.y)); 
        player_h.y = yIso(xOrt(player_h.x,player_h.y)- speed, yOrt(player_h.x,player_h.y));
        //player.anims.play('left', true);
    }
    else if (cursors.right.isDown)
    {
        player_h.x = xIso(xOrt(player_h.x,player_h.y)+ speed, yOrt(player_h.x,player_h.y)); 
        player_h.y = yIso(xOrt(player_h.x,player_h.y)+ speed, yOrt(player_h.x,player_h.y));
        //player.anims.play('right', true);
    }
    else if (cursors.up.isDown)
    {
        player_h.x = xIso(xOrt(player_h.x,player_h.y), yOrt(player_h.x,player_h.y)- speed); 
        player_h.y = yIso(xOrt(player_h.x,player_h.y), yOrt(player_h.x,player_h.y)- speed);
        //player.anims.play('turn');
    }

    else if (cursors.down.isDown)
    {
        player_h.x = xIso(xOrt(player_h.x,player_h.y), yOrt(player_h.x,player_h.y)+ speed); 
        player_h.y = yIso(xOrt(player_h.x,player_h.y), yOrt(player_h.x,player_h.y)+ speed);
    }else{
    	player_h.anims.play('idel', true);
    }

    

}
</script>



</body></html>